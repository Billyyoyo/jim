// Code generated by protoc-gen-go. DO NOT EDIT.
// source: logic.proto

package rpc

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

func init() { proto.RegisterFile("logic.proto", fileDescriptor_60207fea82c31ca8) }

var fileDescriptor_60207fea82c31ca8 = []byte{
	// 350 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x64, 0x92, 0x5d, 0x4b, 0xfb, 0x30,
	0x18, 0xc5, 0x19, 0xff, 0xbf, 0xba, 0x3d, 0xdd, 0xdc, 0x8c, 0x88, 0xd0, 0x4b, 0x41, 0xc1, 0x81,
	0x73, 0xce, 0x17, 0xbc, 0xdd, 0x86, 0x88, 0x2f, 0x43, 0xec, 0x10, 0xc1, 0xbb, 0x2e, 0x7b, 0x56,
	0xc3, 0xda, 0xa4, 0x26, 0x71, 0xb2, 0xcf, 0xec, 0x97, 0x90, 0xa4, 0x2d, 0x36, 0xf5, 0x2e, 0xe7,
	0xe4, 0x77, 0x92, 0x93, 0x87, 0x80, 0x17, 0x8b, 0x88, 0xd1, 0x5e, 0x2a, 0x85, 0x16, 0xe4, 0x9f,
	0x4c, 0xa9, 0xdf, 0x48, 0x54, 0x94, 0x69, 0xbf, 0x49, 0x45, 0x92, 0x08, 0x9e, 0x2b, 0x2f, 0x11,
	0x73, 0x8c, 0x73, 0xd1, 0x08, 0xe9, 0x32, 0x5b, 0x0e, 0xbe, 0xff, 0x43, 0xf3, 0xd1, 0x9c, 0x32,
	0x45, 0xb9, 0x62, 0x14, 0xc9, 0x29, 0xd4, 0x03, 0x8c, 0x98, 0xd2, 0x28, 0x49, 0xa7, 0x27, 0x53,
	0xda, 0x2b, 0x64, 0x80, 0x1f, 0xfe, 0x4e, 0xc5, 0x51, 0x29, 0x39, 0x06, 0xef, 0x16, 0xf5, 0x14,
	0x95, 0x62, 0x82, 0x2b, 0x02, 0x96, 0xb8, 0xe3, 0xfa, 0xea, 0xc2, 0x6f, 0xda, 0x75, 0xbe, 0xd5,
	0xaf, 0x91, 0x2e, 0xc0, 0x2f, 0xea, 0x90, 0x9d, 0x32, 0x69, 0x8f, 0xbd, 0x86, 0xd6, 0x58, 0x62,
	0xa8, 0xb1, 0xc0, 0xf7, 0x2c, 0xe2, 0x78, 0xa6, 0xd1, 0xdf, 0xe4, 0x09, 0x78, 0xf7, 0x82, 0xf1,
	0x22, 0xb7, 0x6b, 0x81, 0x92, 0x63, 0x52, 0x0d, 0x6b, 0x8e, 0x84, 0x88, 0x0d, 0xfe, 0xfc, 0xc9,
	0xb4, 0x8b, 0x97, 0x9c, 0x0a, 0x7e, 0x06, 0xad, 0x00, 0x79, 0x98, 0x54, 0x7a, 0x39, 0x5e, 0x25,
	0xd2, 0x85, 0xed, 0x00, 0x29, 0xb2, 0x15, 0x4e, 0x50, 0xa9, 0x30, 0x42, 0x92, 0x0d, 0x26, 0x57,
	0x7e, 0x36, 0x88, 0x9b, 0x24, 0xd5, 0x6b, 0x72, 0x00, 0x90, 0xb3, 0xc3, 0xf1, 0x03, 0xa9, 0xdb,
	0x9d, 0x21, 0x5d, 0x3a, 0xcc, 0xa1, 0x1d, 0xe3, 0x04, 0x93, 0x19, 0x4a, 0x77, 0xe0, 0xd9, 0xa5,
	0x2f, 0x0a, 0x65, 0xbf, 0x46, 0x06, 0xe0, 0x4d, 0xd7, 0x9c, 0x16, 0x77, 0x66, 0x0f, 0x2b, 0x39,
	0xa6, 0xa5, 0x53, 0xa4, 0x5f, 0x23, 0x97, 0xd0, 0x7e, 0x65, 0xfa, 0x7d, 0x2e, 0xc3, 0xaf, 0x22,
	0xb7, 0x6f, 0x91, 0x8a, 0x5b, 0x79, 0xe1, 0x11, 0x6c, 0x3d, 0x2d, 0x16, 0x31, 0xe3, 0x48, 0xda,
	0xd6, 0xcd, 0x95, 0xc1, 0x4a, 0xcd, 0x47, 0x1b, 0x6f, 0xe6, 0x97, 0xce, 0x36, 0xed, 0xdf, 0x3b,
	0xff, 0x09, 0x00, 0x00, 0xff, 0xff, 0x4b, 0x04, 0x1f, 0x15, 0xc0, 0x02, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// LogicServiceClient is the client API for LogicService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type LogicServiceClient interface {
	Register(ctx context.Context, in *RegisterReq, opts ...grpc.CallOption) (*RegisterResp, error)
	GetSessions(ctx context.Context, in *Int64, opts ...grpc.CallOption) (LogicService_GetSessionsClient, error)
	GetSession(ctx context.Context, in *Int64, opts ...grpc.CallOption) (*SessionResp, error)
	CreateSession(ctx context.Context, in *CreateSessionReq, opts ...grpc.CallOption) (*SessionResp, error)
	JoinSession(ctx context.Context, in *JoinSessionReq, opts ...grpc.CallOption) (*Bool, error)
	QuitSession(ctx context.Context, in *QuitSessionReq, opts ...grpc.CallOption) (*Bool, error)
	RenameSession(ctx context.Context, in *RenameSessionReq, opts ...grpc.CallOption) (*Bool, error)
	ReceiveMessage(ctx context.Context, in *Message, opts ...grpc.CallOption) (*Empty, error)
	ReceiveACK(ctx context.Context, in *Ack, opts ...grpc.CallOption) (*Empty, error)
	GetMembers(ctx context.Context, in *Int64, opts ...grpc.CallOption) (LogicService_GetMembersClient, error)
	SyncMessage(ctx context.Context, in *SyncMessageReq, opts ...grpc.CallOption) (LogicService_SyncMessageClient, error)
	WithdrawMessage(ctx context.Context, in *WithdrawMessageReq, opts ...grpc.CallOption) (*Bool, error)
	Offline(ctx context.Context, in *OfflineReq, opts ...grpc.CallOption) (*Empty, error)
}

type logicServiceClient struct {
	cc *grpc.ClientConn
}

func NewLogicServiceClient(cc *grpc.ClientConn) LogicServiceClient {
	return &logicServiceClient{cc}
}

func (c *logicServiceClient) Register(ctx context.Context, in *RegisterReq, opts ...grpc.CallOption) (*RegisterResp, error) {
	out := new(RegisterResp)
	err := c.cc.Invoke(ctx, "/rpc.LogicService/Register", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logicServiceClient) GetSessions(ctx context.Context, in *Int64, opts ...grpc.CallOption) (LogicService_GetSessionsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_LogicService_serviceDesc.Streams[0], "/rpc.LogicService/GetSessions", opts...)
	if err != nil {
		return nil, err
	}
	x := &logicServiceGetSessionsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type LogicService_GetSessionsClient interface {
	Recv() (*Session, error)
	grpc.ClientStream
}

type logicServiceGetSessionsClient struct {
	grpc.ClientStream
}

func (x *logicServiceGetSessionsClient) Recv() (*Session, error) {
	m := new(Session)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *logicServiceClient) GetSession(ctx context.Context, in *Int64, opts ...grpc.CallOption) (*SessionResp, error) {
	out := new(SessionResp)
	err := c.cc.Invoke(ctx, "/rpc.LogicService/GetSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logicServiceClient) CreateSession(ctx context.Context, in *CreateSessionReq, opts ...grpc.CallOption) (*SessionResp, error) {
	out := new(SessionResp)
	err := c.cc.Invoke(ctx, "/rpc.LogicService/CreateSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logicServiceClient) JoinSession(ctx context.Context, in *JoinSessionReq, opts ...grpc.CallOption) (*Bool, error) {
	out := new(Bool)
	err := c.cc.Invoke(ctx, "/rpc.LogicService/JoinSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logicServiceClient) QuitSession(ctx context.Context, in *QuitSessionReq, opts ...grpc.CallOption) (*Bool, error) {
	out := new(Bool)
	err := c.cc.Invoke(ctx, "/rpc.LogicService/QuitSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logicServiceClient) RenameSession(ctx context.Context, in *RenameSessionReq, opts ...grpc.CallOption) (*Bool, error) {
	out := new(Bool)
	err := c.cc.Invoke(ctx, "/rpc.LogicService/RenameSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logicServiceClient) ReceiveMessage(ctx context.Context, in *Message, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/rpc.LogicService/ReceiveMessage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logicServiceClient) ReceiveACK(ctx context.Context, in *Ack, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/rpc.LogicService/ReceiveACK", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logicServiceClient) GetMembers(ctx context.Context, in *Int64, opts ...grpc.CallOption) (LogicService_GetMembersClient, error) {
	stream, err := c.cc.NewStream(ctx, &_LogicService_serviceDesc.Streams[1], "/rpc.LogicService/GetMembers", opts...)
	if err != nil {
		return nil, err
	}
	x := &logicServiceGetMembersClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type LogicService_GetMembersClient interface {
	Recv() (*User, error)
	grpc.ClientStream
}

type logicServiceGetMembersClient struct {
	grpc.ClientStream
}

func (x *logicServiceGetMembersClient) Recv() (*User, error) {
	m := new(User)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *logicServiceClient) SyncMessage(ctx context.Context, in *SyncMessageReq, opts ...grpc.CallOption) (LogicService_SyncMessageClient, error) {
	stream, err := c.cc.NewStream(ctx, &_LogicService_serviceDesc.Streams[2], "/rpc.LogicService/SyncMessage", opts...)
	if err != nil {
		return nil, err
	}
	x := &logicServiceSyncMessageClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type LogicService_SyncMessageClient interface {
	Recv() (*Message, error)
	grpc.ClientStream
}

type logicServiceSyncMessageClient struct {
	grpc.ClientStream
}

func (x *logicServiceSyncMessageClient) Recv() (*Message, error) {
	m := new(Message)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *logicServiceClient) WithdrawMessage(ctx context.Context, in *WithdrawMessageReq, opts ...grpc.CallOption) (*Bool, error) {
	out := new(Bool)
	err := c.cc.Invoke(ctx, "/rpc.LogicService/WithdrawMessage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logicServiceClient) Offline(ctx context.Context, in *OfflineReq, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/rpc.LogicService/Offline", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LogicServiceServer is the server API for LogicService service.
type LogicServiceServer interface {
	Register(context.Context, *RegisterReq) (*RegisterResp, error)
	GetSessions(*Int64, LogicService_GetSessionsServer) error
	GetSession(context.Context, *Int64) (*SessionResp, error)
	CreateSession(context.Context, *CreateSessionReq) (*SessionResp, error)
	JoinSession(context.Context, *JoinSessionReq) (*Bool, error)
	QuitSession(context.Context, *QuitSessionReq) (*Bool, error)
	RenameSession(context.Context, *RenameSessionReq) (*Bool, error)
	ReceiveMessage(context.Context, *Message) (*Empty, error)
	ReceiveACK(context.Context, *Ack) (*Empty, error)
	GetMembers(*Int64, LogicService_GetMembersServer) error
	SyncMessage(*SyncMessageReq, LogicService_SyncMessageServer) error
	WithdrawMessage(context.Context, *WithdrawMessageReq) (*Bool, error)
	Offline(context.Context, *OfflineReq) (*Empty, error)
}

// UnimplementedLogicServiceServer can be embedded to have forward compatible implementations.
type UnimplementedLogicServiceServer struct {
}

func (*UnimplementedLogicServiceServer) Register(ctx context.Context, req *RegisterReq) (*RegisterResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Register not implemented")
}
func (*UnimplementedLogicServiceServer) GetSessions(req *Int64, srv LogicService_GetSessionsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetSessions not implemented")
}
func (*UnimplementedLogicServiceServer) GetSession(ctx context.Context, req *Int64) (*SessionResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSession not implemented")
}
func (*UnimplementedLogicServiceServer) CreateSession(ctx context.Context, req *CreateSessionReq) (*SessionResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSession not implemented")
}
func (*UnimplementedLogicServiceServer) JoinSession(ctx context.Context, req *JoinSessionReq) (*Bool, error) {
	return nil, status.Errorf(codes.Unimplemented, "method JoinSession not implemented")
}
func (*UnimplementedLogicServiceServer) QuitSession(ctx context.Context, req *QuitSessionReq) (*Bool, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QuitSession not implemented")
}
func (*UnimplementedLogicServiceServer) RenameSession(ctx context.Context, req *RenameSessionReq) (*Bool, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RenameSession not implemented")
}
func (*UnimplementedLogicServiceServer) ReceiveMessage(ctx context.Context, req *Message) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReceiveMessage not implemented")
}
func (*UnimplementedLogicServiceServer) ReceiveACK(ctx context.Context, req *Ack) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReceiveACK not implemented")
}
func (*UnimplementedLogicServiceServer) GetMembers(req *Int64, srv LogicService_GetMembersServer) error {
	return status.Errorf(codes.Unimplemented, "method GetMembers not implemented")
}
func (*UnimplementedLogicServiceServer) SyncMessage(req *SyncMessageReq, srv LogicService_SyncMessageServer) error {
	return status.Errorf(codes.Unimplemented, "method SyncMessage not implemented")
}
func (*UnimplementedLogicServiceServer) WithdrawMessage(ctx context.Context, req *WithdrawMessageReq) (*Bool, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WithdrawMessage not implemented")
}
func (*UnimplementedLogicServiceServer) Offline(ctx context.Context, req *OfflineReq) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Offline not implemented")
}

func RegisterLogicServiceServer(s *grpc.Server, srv LogicServiceServer) {
	s.RegisterService(&_LogicService_serviceDesc, srv)
}

func _LogicService_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogicServiceServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.LogicService/Register",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogicServiceServer).Register(ctx, req.(*RegisterReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LogicService_GetSessions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Int64)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LogicServiceServer).GetSessions(m, &logicServiceGetSessionsServer{stream})
}

type LogicService_GetSessionsServer interface {
	Send(*Session) error
	grpc.ServerStream
}

type logicServiceGetSessionsServer struct {
	grpc.ServerStream
}

func (x *logicServiceGetSessionsServer) Send(m *Session) error {
	return x.ServerStream.SendMsg(m)
}

func _LogicService_GetSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Int64)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogicServiceServer).GetSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.LogicService/GetSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogicServiceServer).GetSession(ctx, req.(*Int64))
	}
	return interceptor(ctx, in, info, handler)
}

func _LogicService_CreateSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSessionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogicServiceServer).CreateSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.LogicService/CreateSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogicServiceServer).CreateSession(ctx, req.(*CreateSessionReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LogicService_JoinSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JoinSessionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogicServiceServer).JoinSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.LogicService/JoinSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogicServiceServer).JoinSession(ctx, req.(*JoinSessionReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LogicService_QuitSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuitSessionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogicServiceServer).QuitSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.LogicService/QuitSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogicServiceServer).QuitSession(ctx, req.(*QuitSessionReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LogicService_RenameSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RenameSessionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogicServiceServer).RenameSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.LogicService/RenameSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogicServiceServer).RenameSession(ctx, req.(*RenameSessionReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LogicService_ReceiveMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Message)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogicServiceServer).ReceiveMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.LogicService/ReceiveMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogicServiceServer).ReceiveMessage(ctx, req.(*Message))
	}
	return interceptor(ctx, in, info, handler)
}

func _LogicService_ReceiveACK_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ack)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogicServiceServer).ReceiveACK(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.LogicService/ReceiveACK",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogicServiceServer).ReceiveACK(ctx, req.(*Ack))
	}
	return interceptor(ctx, in, info, handler)
}

func _LogicService_GetMembers_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Int64)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LogicServiceServer).GetMembers(m, &logicServiceGetMembersServer{stream})
}

type LogicService_GetMembersServer interface {
	Send(*User) error
	grpc.ServerStream
}

type logicServiceGetMembersServer struct {
	grpc.ServerStream
}

func (x *logicServiceGetMembersServer) Send(m *User) error {
	return x.ServerStream.SendMsg(m)
}

func _LogicService_SyncMessage_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SyncMessageReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LogicServiceServer).SyncMessage(m, &logicServiceSyncMessageServer{stream})
}

type LogicService_SyncMessageServer interface {
	Send(*Message) error
	grpc.ServerStream
}

type logicServiceSyncMessageServer struct {
	grpc.ServerStream
}

func (x *logicServiceSyncMessageServer) Send(m *Message) error {
	return x.ServerStream.SendMsg(m)
}

func _LogicService_WithdrawMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithdrawMessageReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogicServiceServer).WithdrawMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.LogicService/WithdrawMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogicServiceServer).WithdrawMessage(ctx, req.(*WithdrawMessageReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LogicService_Offline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OfflineReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogicServiceServer).Offline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.LogicService/Offline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogicServiceServer).Offline(ctx, req.(*OfflineReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _LogicService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.LogicService",
	HandlerType: (*LogicServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Register",
			Handler:    _LogicService_Register_Handler,
		},
		{
			MethodName: "GetSession",
			Handler:    _LogicService_GetSession_Handler,
		},
		{
			MethodName: "CreateSession",
			Handler:    _LogicService_CreateSession_Handler,
		},
		{
			MethodName: "JoinSession",
			Handler:    _LogicService_JoinSession_Handler,
		},
		{
			MethodName: "QuitSession",
			Handler:    _LogicService_QuitSession_Handler,
		},
		{
			MethodName: "RenameSession",
			Handler:    _LogicService_RenameSession_Handler,
		},
		{
			MethodName: "ReceiveMessage",
			Handler:    _LogicService_ReceiveMessage_Handler,
		},
		{
			MethodName: "ReceiveACK",
			Handler:    _LogicService_ReceiveACK_Handler,
		},
		{
			MethodName: "WithdrawMessage",
			Handler:    _LogicService_WithdrawMessage_Handler,
		},
		{
			MethodName: "Offline",
			Handler:    _LogicService_Offline_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetSessions",
			Handler:       _LogicService_GetSessions_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetMembers",
			Handler:       _LogicService_GetMembers_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SyncMessage",
			Handler:       _LogicService_SyncMessage_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "logic.proto",
}
